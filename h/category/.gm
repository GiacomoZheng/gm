: ; + category
(
	âŠ† â—‰, ; a category of `A` is something represent some property of `A` (which might be a structure)
	(
		âˆ€ð’ž: âˆˆ category,
		ð’ž.object: âŠ† â—‰,
		ð’ž.morphism: ; ! I think there is some ambiguity here
		(
			; here means I can pick sth as the `ð’ž.morphism`
			âŠ† â—‰,
			âˆ€f: âˆˆ ð’ž.morphism,
			f.source: âˆˆ ð’ž.object, f.target: âˆˆ ð’ž.object,
			; ! I need to define the equality of it, which should not be allowed
		),

		ð’ž.morphism[âˆ€A: âˆˆ ð’ž.object]: ; ! I think there is some ambiguity here
		(
			; here means everything in `ð’ž.morphism` is in it if it satisfies some condition
			âŠ† ð’ž.morphism,
			âˆ€f: âˆˆ ð’ž.morphism[A],
			f.source = A
		),
		ð’ž.morphism[âˆ€A: âˆˆ ð’ž.object][âˆ€B: âˆˆ ð’ž.object]: ; ! I think there is some ambiguity here
		(
			; here means everything in `ð’ž.morphism` is in it if it satisfies some condition
			âŠ† ð’ž.morphism[A],
			âˆ€f: âˆˆ ð’ž.morphism[A][B],
			f.target = B
		),

		ð’ž.composition(âˆ€g: âˆˆ ð’ž.morphism)(âˆ€f: âˆˆ ð’ž.morphism[g.target]): âˆˆ ð’ž.morphism[g.source][f.target],
	),
	; location
		; about tools
		; end
),

[ I'll delete the below parts```
(
	"maybe concrete category",
	âŠ† class.sub(set), ; a category is a subclass of set
	(
		âˆ€c: âˆˆ category,
		c.morphism: âŠ† set.morphism, ; + now I think it should be like a set to set map
		âˆ€f: âˆˆ c.morphism, f.D âˆˆ c, f.C âˆˆ c,
		; I'm considering about something called natrural subsets (like topology)

		; attributes
			c.morphism[âˆ€X: âˆˆ c][âˆ€Y: âˆˆ c]:
			(
				âŠ† c.morphism,
				âˆ€f: âˆˆ c.morphism[X][Y],
				f.D = X, f.C = Y
			),

			c.Mor(âˆ€X: âˆˆ c)(âˆ€Y: âˆˆ c): , ; + I don't know what is it yet
	),
	; location
		filtered_index: ; + or filtered_index_category
		(
			âŠ† category,
			âˆ€c: âˆˆ filtered_index,
			âˆ€X: âˆˆ c, âˆ€Y: âˆˆ c, âˆƒZ: âˆˆ c,
			c.morphism[X][Z] âˆˆ class.nonempty, ; X â†’ Z
			c.morphism[Y][Z] âˆˆ class.nonempty, ; Y â†’ Z
			; and 
			âˆ€f: âˆˆ c.morphism[X][Y], âˆ€g: âˆˆ c.morphism[X][Y], ; may be âˆ€{f, g}: âŠ† c.Mor(X)(Y)
			âˆƒh: âˆˆ c.morphism[Y][Z],
			h âˆ˜ f c.morphism.= h âˆ˜ g ; ? =
		),
		; + 1.4.D. EXECRISE
),
```]

[ save a diagram:
			f
		D	-->	C
		|		| 
	D.oper(x)	C.oper(x)
		âˆ¨		âˆ¨
		D	-->	C 
			f
]