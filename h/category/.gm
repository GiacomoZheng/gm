: ; + category
(
	âŠ† â—‰, ; a category of `A` is something represent some property of `A` (which might be a structure)
	(
		âˆ€ð’ž: âˆˆ category,
		ð’ž.object: âŠ† â—‰,
		ð’ž.morphism: ; ! I think there is some ambiguity here
		(
			; here means I can pick sth as the `ð’ž.morphism`
			âŠ† â—‰,
			(
				âˆ€f: âˆˆ ð’ž.morphism,
				f.source: âˆˆ ð’ž.object, f.target: âˆˆ ð’ž.object,
				; ! I need to define the equality of it, which should not be allowed
			),
			; locations
				from[âˆ€A: âˆˆ object]:
				(
					âŠ† ð’ž.morphism,
					âˆ€f: âˆˆ from[A], f.source = A
				),
				to[âˆ€B: âˆˆ object]:
				(
					âŠ† ð’ž.morphism,
					âˆ€f: âˆˆ to[B], f.target = B
				),
				from[âˆ€A: âˆˆ object]to[âˆ€B: âˆˆ object]:
				(
					âŠ† from[A],
					âŠ† to[B]
				),
		),
		ð’ž.morphism[âˆ€A: âˆˆ ð’ž.object][âˆ€B: âˆˆ ð’ž.object]: = ð’ž.morphism.from[A]to[B],

		ð’ž.composition(âˆ€g: âˆˆ ð’ž.morphism)(âˆ€f: âˆˆ ð’ž.morphism.from[g.target]): âˆˆ ð’ž.morphism.from[g.source]to[f.target], ; f âˆ˜ g
		[ it is to say```
			âˆ€A: âˆˆ object, âˆ€B: âˆˆ object, âˆ€C: âˆˆ object,
			âˆ€g: âˆˆ morphism[A][B], âˆ€f: âˆˆ morphism[B][C],
			âˆƒh: âˆˆ morphism[A][C], composition(g)(f) morphism.= h ; f âˆ˜ g = h
		``` ]

		ð’ž.âˆ˜: = operator[ð’ž.composition], ; + operator for this case

		(@ð’ž,
			âˆ€A: âˆˆ object, âˆ€B: âˆˆ object, âˆ€C: âˆˆ object, âˆ€D: âˆˆ object,
			âˆ€h: âˆˆ morphism[A][B], âˆ€g: âˆˆ morphism[B][C], âˆ€f: âˆˆ morphism[C][D],
			(f âˆ˜ g) âˆ˜ h morphism.= f âˆ˜ (g âˆ˜ h)
		â– ),; associativity

		ð’ž.identity_morphism[âˆ€A: âˆˆ ð’ž.object]: âˆˆ ð’ž.morphism.from[A]to[A],

		(@ð’ž,
			âˆ€A: âˆˆ object, âˆ€B: âˆˆ object,
			(
				âˆ€f: âˆˆ morphism.from[A], f âˆ˜ ð’ž.identity_morphism[A] morphism.= f
			),
			(
				âˆ€g: âˆˆ morphism.to[A], ð’ž.identity_morphism[A] âˆ˜ g morphism.= g
			),
		â– ), ; criterion about identity_morphism
	),
	; location
		; about tools
		; end
),

[ I'll delete the below parts```
(
	; location
		filtered_index: ; + or filtered_index_category
		(
			âŠ† category,
			âˆ€c: âˆˆ filtered_index,
			âˆ€X: âˆˆ c, âˆ€Y: âˆˆ c, âˆƒZ: âˆˆ c,
			c.morphism[X][Z] âˆˆ class.nonempty, ; X â†’ Z
			c.morphism[Y][Z] âˆˆ class.nonempty, ; Y â†’ Z
			; and 
			âˆ€f: âˆˆ c.morphism[X][Y], âˆ€g: âˆˆ c.morphism[X][Y], ; may be âˆ€{f, g}: âŠ† c.Mor(X)(Y)
			âˆƒh: âˆˆ c.morphism[Y][Z],
			h âˆ˜ f c.morphism.= h âˆ˜ g ; ? =
		),
		; + 1.4.D. EXECRISE
),
```]

[ save a diagram:
			f
		D	-->	C
		|		| 
	D.oper(x)	C.oper(x)
		âˆ¨		âˆ¨
		D	-->	C 
			f
]