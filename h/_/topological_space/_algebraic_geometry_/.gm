; about sheaf
	presheaf[âˆ€type: âˆˆ structure](âˆ€X: âˆˆ topological_space): ; = â„±(X) in The Rising Sea: FOAGnov1817 
	(
		"a presheaf of the type (like set) on/over X",
		âˆˆ structure.sub(type),
		âˆ€â„±: âˆˆ presheaf[type](X),

		â„±.section: = â„±.element, ; â„± is a set and elements of it are called sections

		â„±.on[âˆ€U: âˆˆ X.open]: âˆˆ type, ; may not be the quotient of â„±, think about S^1\{p}
		â„±.on[X] = â„±,
		â„±.on[âˆ…] âˆˆ type.final, ; criterion 1

		â„±.res[âˆ€V: âˆˆ X.open][âˆ€U: âˆˆ X.open_sub(V)]: âˆˆ type.Hom(â„±.on[V], â„±.on[U]), ; ? is it enough
			â„±.restriction[âˆ€V: âˆˆ X.open][âˆ€U: âˆˆ X.open_sub(V)]: = â„±.res[V][U],
		
		â„±.res[âˆ€U: âˆˆ X.open]: = â„±.res[X][U],
		
		(
			âˆ€U: âˆˆ X.open,
			â„±.res[U][U] = type.identity_morphism,
		), ; criterion 2

		(
			âˆ€W: âˆˆ X.open, âˆ€V: âˆˆ X.open, âˆ€U: âˆˆ X.open, 
			W âŠ† V âŠ† U â‡’ â„±.res[W][V] âˆ˜ â„±.res[V][U] = â„±.res[W][U]
		), ; criteria 3

		; location
			â„±.at[âˆ€p: âˆˆ X]: ; +
			(
				"stalk at p",
				âˆˆ type.quotient(â„±), ; !
				R(âˆ€f: âˆˆ â„±):
				(
					âŠ† set.element(â„±),
					âˆ€g: âˆˆ R(f),

					âˆƒU: âˆˆ X.open,
					@â„±,
						res[U] f = res[U] g
					â– 
				)
				set.= R.partition,

				; location
					â„±.at[p].germ: = â„±.element, ; element of it is a germ at p
			),
			[ property: 
				if {p} is open, `at[p] = on[{p}]`
			]

			â„±.res[âˆ€V: âˆˆ X.open][âˆ€p: âˆˆ V]: ; ?
			â„±.res[âˆ€p: âˆˆ V]: = â„±.res[V][p],

			â„±.compatible_sections:
			(
				; !
				âŠ† set[â„±.section], ; ! not what I want
				
				; âˆ€V: âˆˆ ğ’°, âˆ€W: âˆˆ ğ’°,
				; res[V][V âˆ© W](f[V]) = res[W][V âˆ© W](f[W])
			)

			homomorphism:
			(
				; âŠ† type.homomorphism,
				âˆ€f: âˆˆ homomorphism,
				; @f,
				; 	âˆ€U: âˆˆ X.open,
				; 	f.res[â„±.on[U]] âˆˆ type.homomorphism,
				; â–  
				; ? Do I need this part?
				@f,
					âˆ€V: âˆˆ X.open, âˆ€U: âˆˆ X.open_sub(V),
					f.res[â„±.on[U]] âˆ˜ D.res[V][U] = D.res[V][U] âˆ˜ f.res[â„±.on[V]]
				â– 
			)
			; ? morphism:
			; ? sub


	),
	[ properties:
		* â„±.on[U] and â„±.at[p] are still presheaf
	]

	separated_presheaf[âˆ€type: âˆˆ structure](âˆ€X: âˆˆ topological_space):
	(
		âˆˆ structure.sub(presheaf[type](X)),

		; identity axiom
		âˆ€U: âˆˆ X.open,
		âˆ€ğ’°: âˆˆ X.open_cover(U),
		âˆ€f: âˆˆ â„±.on[U], âˆ€g: âˆˆ â„±.on[U],
		@â„±,
			(âˆ€V: âˆˆ ğ’°, res[U][V](f) = res[U][V](g)) ; â„±.= ? where â„± is a set
			â‡’ f = g
		â– 
	),

	sheaf[âˆ€type: âˆˆ structure](âˆ€X: âˆˆ topological_space):
	(
		âˆˆ structure.sub(separated_presheaf[type](X)),

		; gluability axiom
		âˆ€U: âˆˆ X.open,
		âˆ€ğ’°: âˆˆ X.open_cover(U),
		âˆ€f[âˆ€V: âˆˆ ğ’°]: âˆˆ â„±.on[V],
		@â„±,
			{f[V]}[âˆ€V: âˆˆ ğ’°] âˆˆ compatible ; + compatible
			â‡’ 
			(
				âˆƒf: âˆˆ â„±.on[U], âˆ€V: âˆˆ ğ’°, res[U][V](f) = f[V]
			)
		â– 
	),

	; about examples
		; skyscraper_sheaf

		constant_presheaf[âˆ€S: âˆˆ set](âˆ€X: âˆˆ topological_space):
		(
			"the constant_presheaf associated to S on X",
			âˆˆ presheaf[S](X),
			constant_presheaf[S](X).on[âˆ€U: âˆˆ X.open]: = S, ; on other sense constant map {f : X â†’ S}

			constant_presheaf[S](X).res[âˆ€V: âˆˆ X.open][âˆ€U: âˆˆ X.open_sub(V)]: = type.identity_morphism[S] ; identity_map
		),

		constant_sheaf[âˆ€S: âˆˆ set](âˆ€X: âˆˆ topological_space):
		(
			; +
		)
	; end	
; end