: ; topological_space
(
	"topological space via approach to",
	; ! I cannot deal with some problems like Hausdorff and compact now
	âŠ† set, ; *** I choose my "â†’" version
	(
		âˆ€X: âˆˆ topological_space,
		X.â†’: âˆˆ preorder_relator,
		X âŠ† &X.â†’&.D,
		[ equivalently```
			X.Ï„:
			(
				"a set of subsets of X",
				âŠ† Ps(X),
				âˆ… âˆˆ X.Ï„, X âˆˆ X.Ï„,
				âˆ€{A, B}: âŠ† X.Ï„, A âˆ© B âˆˆ X.Ï„,
				âˆ€ğ’: âŠ† X.Ï„, âˆ©(ğ’) âˆˆ X.Ï„, ; !
			),

			X.nbh: , ; the same

			X.â†’:
			(
				âŠ† relator,
				âˆ€{x, y}: âŠ† X,
				x X.â†’ y â‡” X.nbh(x) âŠ‡ X.nhb(y)
			)
		``` ]
		
		[ attibutions ]
			; via open set
				X.basis: , ; +

				X.Ï„: ; + from basis
				(
					âŠ† Ps(X), ; it is a set
					âˆ… âˆˆ X.Ï„, X âˆˆ X.Ï„,
					; âˆ€{A, B}: âŠ† X.Ï„, A âˆ© B âˆˆ X.Ï„,
					; âˆ€ğ’: âŠ† X.Ï„, âˆ©(ğ’) âˆˆ X.Ï„, ; !

					âˆ€x: âˆˆ X, {yâ”‚y X.â†’ x}[âˆ€y: âˆˆ T] âˆˆ X.Ï„ ; * to be consistent with â†’
				),
				; about alias
					X.base: = X.basis,
					X.ğ’¯: = X.Ï„, ; I won't this one later
					X.topology: = X.Ï„,
					X.open: = set.element(X.Ï„), ; directly trans it to a class
				; end
			; end

			; via neighborhood
				X.nbh(âˆ€x: âˆˆ X):
				(
					âŠ† set.sub(X),
					âˆ€Y: âˆˆ X.nbh(x),
					âˆƒO: âˆˆ X.Ï„, x âˆˆ O,
					O âŠ† Y
				),
				; about alias
					X.Nbh: = X.nbh,
					X.neighborhood: = X.nbh,
				; end
			; end

			; via closed set
				X.closed:
				(
					âŠ† set.sub(X),
					âˆ€F: âˆˆ closed(X),
					âˆ€x: âˆˆ X, (âˆƒy: âˆˆ F, y X.â†’ x) â‡’ x âˆˆ F
				),
			; end

			; about arrow
				X.â†:
				(
					âˆˆ relator,
					âˆ€{a, b}: âŠ† X, a X.â† b â‡” b X.â†’ a
				),

				X.â†”: ; * Topological indistinguishability
				(
					âˆˆ relator,
					âˆ€{a, b}: âŠ† X, a X.â†” b â‡” âˆ€(a X.â†’ b, b X.â†’ a)
				),
			; end
	),

	[ for location ]
		; about alias
			topology(âˆ€X: âˆˆ topological_space): = X.Ï„, ; a set
			open(âˆ€X: âˆˆ topological_space): = X.open, ; a class
			closed(âˆ€X: âˆˆ topological_space): = X.closed,

			close_set: = closed, ; ? someone others may use it
			homeomorphism: = isomorphism, ; I don't like it name
			bicontinuous_function: = isomorphism,
		; end

		; + about inheritance
			sub(âˆ€S: âˆˆ topological_space):
			(
				"sub topological space",
				âŠ† set.sub(S),
				âŠ† topological_space,
				âˆ€A: âˆˆ sub(S),
				&A.â†’& = &S.â†’& ; ?
			),
		; end

		limit_point[âˆ€X: âˆˆ topological_space](âˆ€A: âŠ† X):
		(
			= {x|âˆ€N: âˆˆ X.nbh(x), !(A âˆ© N\{x} = âˆ…)}[ ; + bug ... 
				âˆ€x: âˆˆ X]
		),

		closure[âˆ€X: âˆˆ topological_space](âˆ€A: âŠ† X): = {x|âˆƒa: âˆˆ A, a X.â†’ x}[âˆ€x: âˆˆ X], ; directly A âŠ† its closure

		basis(topology(âˆ€X: âˆˆ topological_space)): ; ? package definition, æ‰“åŒ…å®šä¹‰
		(
			; +
			"the smallest subsets whose sub-union consist all the open sets(except âˆ…)",
			=
		),
		[ equivalently```
			basis(âˆ€S: âˆˆ `setofsets`):,
		``` ]

		open_cover(âˆ€C: âˆˆ topological_space):
		(
			âŠ† set.cover(C),
			âˆ€ğ’: âˆˆ open_cover(C),
			ğ’ âŠ† C.Ï„
		),

		dense_sub(âˆ€X: âˆˆ topological_space):
		(
			âŠ† set.sub(X),
			âˆ€D: âˆˆ dense_sub(X),
			closure[X](D) = X
		),
		[ I may write down some equivalent version of it ]
),