: ; topological_space, or top'space
(
	"topological space via topology (open set)",
	âŠ† set, ; * I have given up my "â†’" version ; ! I cannot deal with some problems like Hausdorff and compact with my version now
	(
		âˆ€X: âˆˆ topological_space,
		X.Ï„: âˆˆ topology(X), ; defined in the tools
			X.ğ’¯: = X.Ï„, ; I won't use this one later
			; ! X.topology: ; it may cause me confused
			X.open: = set.element(X.Ï„), ; just trans it to a class

		; attibutions
			; via open set
				X.basis: ; do not be confuse with the basis in tools
				(
					âŠ† sub(X.Ï„), ; a class
					âˆ€â„¬: âˆˆ X.basis,
					âˆ€U: âˆˆ Ï„, âˆƒâ„¬': âŠ† â„¬, U = âˆª(â„¬')
					; for U = âˆ…, just pick â„¬' empty
				),
					X.base: = X.basis,
				
				X.subbasis:
				(
					"is a subset of basis but not a subclass of basis",
					âŠ† sub(X.Ï„),

				)

				X.open_cover(âˆ€A: âˆˆ sub(X)): ; ?
				(
					âŠ† X.cover(A),
					âŠ† set.sub(X.Ï„)
				),
			; end

			; via neighborhood
				X.nbh(âˆ€x: âˆˆ X):
				(
					âŠ† set.sub(X),
					âˆ€Y: âˆˆ X.nbh(x),
					âˆƒO: âˆˆ X.Ï„, x âˆˆ O,
					O âŠ† Y
				),
				; about alias
					X.Nbh: = X.nbh,
					X.neighborhood: = X.nbh,
				; end
			; end

			; via closed set
				X.closed: ; ?
				(
					âŠ† set.sub(X),
					âˆ€F: âˆˆ closed(X),
					âˆ€x: âˆˆ X, (âˆƒy: âˆˆ F, y X.â†’ x) â‡’ x âˆˆ F
				),
			; end

			; ! about arrow
				X.approach_to(âˆ€x: âˆˆ X): ; ?
				(
					âŠ† sub(X),
					(
						âˆ€y: âˆˆ X.approach_to(x),
						X.nbh(x) âŠ† X.nbh(y) ; â—‰.âŠ†
					)
				),
				X.â†’: = relator[X.approach_to],

				X.be_approached_to: = relation.inv(X.approach_to)
				X.â†’: = relator[X.be_approached_to],

				X.be_indistinguishable_with(âˆ€x: âˆˆ X):
				(
					âŠ† X.approach_to(x),
					âŠ† X.be_approached_to(x)
				),
					X.be_topological_indistinguishable_with: = X.be_indistinguishable_with, ; ?
				X.â†”: = relator[X.be_indistinguishable_with],
			; end

			; ? about closure interor and boundary
				; * be attension, the `A` below are all just subset, not subspace
				X.accumulation_point(âˆ€A: âŠ† X):
				(
					âŠ† set.element(X),
					âˆ€x: âˆˆ X.accumulation_point(A),
					âˆ€N: âˆˆ X.nbh(x), Â¬((N \ {x}) âˆ© A = âˆ…)
				),
					X.limit_point: = X.accumulation_point,
					X.cluster_point: = X.accumulation_point,
				
				
				X.closure_point(âˆ€A: âŠ† X):
				(
					âŠ† set.element(X),
					âˆ€x: âˆˆ X.closure_point(A),
					âˆ€N: âˆˆ X.nbh(x), Â¬(N âˆ© A = âˆ…)
				)
				X.closure(âˆ€A: âŠ† X): = {âˆ€x: âˆˆ X.closure_point} ; the minimal closed set in X containing the A ; or = {x|âˆƒa: âˆˆ A, a X.â†’ x}[âˆ€x: âˆˆ X], ; ?

				X.interior_point(âˆ€A: âŠ† X):
				(
					âŠ† set.element(X),
					âˆ€x: âˆˆ X.interior_point(A), A âˆˆ X.nbh(x)
				),
				X.interior(âˆ€A: âŠ† X): = {âˆ€x: âˆˆ X.interior_point(A)}, ; the maximal open set in X contained in the A,

				X.exterior(âˆ€A: âŠ† X): = X.interior(X \ A),

				X.boundary_point(âˆ€A: âŠ† X):
				(
					âŠ† X.closure_point(A),
					âŠ† X.closure_point(X \ A)
				),
				X.boundary(âˆ€A: âŠ† X): = X.closure(A) \ X.interior(A),
			; end
	),

	; location
		; about tools
			topology(âˆ€X: âˆˆ set): ; +
			(
				"a topological structure on X",
				âŠ† X.cover,
				âˆ€Ï„: âˆˆ topology(X),
				(âˆ… âˆˆ Ï„),
				(âˆ€{A, B}: âŠ† Ï„, A âˆ© B âˆˆ Ï„),
				(âˆ€ğ’: âŠ† Ï„, âˆª(ğ’) âˆˆ Ï„) ; ! âˆª ; so that D âˆˆ Ï„
			),
			[ cover + union closure â‡’ D âˆˆ Ï„ ]

			basis(âˆ€D: âˆˆ set): ; ? space ; or base
			(
				"generated a topological space from a of basis",
				âŠ† cover(D),
				âˆ€{B1, B2}: âˆˆ â„¬, âˆ€x: âˆˆ B1 âˆ© B2,
				âˆƒB: âˆˆ â„¬, x âˆˆ B âŠ† B1 âˆ© B2
			),
		; end

		; about alias
			; about basic
				base: = basis,

				open(âˆ€X: âˆˆ topological_space): = X.open, ; a class
				closed(âˆ€X: âˆˆ topological_space): = X.closed,

				open_cover(âˆ€X: âˆˆ topological_space): = X.open_cover(X),

				accumulation_point[âˆ€X: âˆˆ topological_space]: X.accumulation_point,
				limit_point[âˆ€X: âˆˆ topological_space]: = X.accumulation_point,

				closure_point[âˆ€X: âˆˆ topological_space]: = X.closure_point,
					closure[âˆ€X: âˆˆ topological_space]: = X.closure,
				interior_point[âˆ€X: âˆˆ topological_space]: = X.interior_point,
					interior[âˆ€X: âˆˆ topological_space]: = X.interior,
				exterior_point[âˆ€X: âˆˆ topological_space]: = X.exterior_point,
					exterior[âˆ€X: âˆˆ topological_space]: = X.exterior,
				boundary_point[âˆ€X: âˆˆ topological_space]: = X.boundary_point,
					boundary[âˆ€X: âˆˆ topological_space]: = X.boundary,
			; end

			; about function and morphism
				continuous_map: = continuous_function,
				quotient_map: = epimorphism,
			; end

			; about separable axiom
				T0_space: = Kolmogorov_space,
				T1_space: = accessible_space,
					; ! FrÃ©chet_space: = accessible_space, ; ? this name might be confusing
				T2_space: = Hausdorff_space,
			; end

			; about connectness
				connected_component: = connected_space.component
			; end
		; end

		; + about inheritance
			sub(âˆ€S: âˆˆ topological_space): ; or topological_subspace
			(
				"sub topological space",
				âŠ† set.sub(S),
				âŠ† topological_space,
				âˆ€A: âˆˆ sub(S),
				A.Ï„: = {U âˆ© A}[âˆ€U: âˆˆ X.Ï„] ; ?
			),
			; any subset of X is a sub of it

			Ã—: ; + I may change the corresponding definition in group as well
			(
				âˆˆ operator, ; !
				âˆ€A: âˆˆ topological_space, âˆ€B: âˆˆ topological_space,
				(A Ã— B): set.= A set.Ã— B, ; ?
				{U Ã— V}[âˆ€U: âˆˆ A.Ï„, âˆ€V: âˆˆ B.Ï„] âˆˆ (A Ã— B).basis
			),

			âŠ†: , ; ? I don't know up to now

			quotient(âˆ€X: âˆˆ topological_space): ; or identification_space
			(
				âŠ† set.quotient(X),
				âŠ† topological_space,
				âˆ€Q: âˆˆ quotient,
				Q.Ï„ = {U|âˆª(U) âˆˆ X.Ï„}[âˆ€U: âˆˆ Q] ; ? âˆª
			),

			isomorphic(âˆ€X: âˆˆ topological_space): ; ?
			(
				âŠ† topological_space,
				âˆ€T: âˆˆ isomorphic(X),
				âˆƒf: âˆˆ isomorphism, âˆ€(f.D = X, f.C = T)
			),
			â‰Œ: = relator[isomorphic],
		; end
				
		; about continuity
			C(âˆ€S: âˆˆ topological_space, âˆ€T: âˆˆ topological_space): = {f|f âˆˆ continuous_map}[f âˆˆ set.Hom(S, T)], ; space of continous function

			homeomorphic(âˆ€T: âˆˆ topological_space):
			(
				âŠ† topological_space,
				âˆ€S: âˆˆ homeomorphic(T),
				âˆƒf: âˆˆ homeomorphism, f.D = S, f.C = T
				[ while, homeomorphism = isomorphism ]
			),
		; end

		; about special subspace
			; for intrinsic
				connected_sub(âˆ€X: âˆˆ topological_space):
				(
					âŠ† set.sub(X),
					âŠ† connected_space,
				),

				compact_sub(âˆ€X: âˆˆ topological_space):
				(
					âŠ† set.sub(X),
					âŠ† compact_space
				),
			; end

			; for extrinsic
				dense_sub(âˆ€X: âˆˆ topological_space): ; ? I may write down some equivalent version for it
				(
					âŠ† set.sub(X),
					âˆ€D: âˆˆ dense_sub(X),
					X.closure(D) = X
				),
			; end
		; end

		; about covering space
			evenly_covered(âˆ€p: âˆˆ continuous_function):
			(
				"evenly covered over p",
				âŠ† connected_sub(p.C), ; may not be open ; ? connected as I want to use the connected component to simplify the definition
				(
					âˆ€U: âˆˆ evenly_covered(p),
					âˆ€sheet: âˆˆ connected_component(p.preimage(U)), ; the preimage may be empty
					p.restriction[sheet][U] âˆˆ homeomorphism
				)
			),

			covering_space(âˆ€X: âˆˆ connected_space): ; ? whether should I preserve the X here
			(
				; Source from "Allen Hatcher - Algebraic Topology"
				; the connected space X makes the index a constant
				âŠ† topological_space, ; allow disconnected space
				(
					âˆ€C: âˆˆ covering_space(X),
					; C.base_space: = X, ; I think it useless
					C.p: âˆˆ topological_space.C(C, X), ; covering map (also covering projection), may not be surjective ; ! X should be temporary
					âˆ€x: âˆˆ X,  âˆƒU: âˆˆ X.nbh(x), U âˆˆ evenly_covered(p)
				),
				; location
					isomorphism:
					(
						âŠ† homeomorphism, ; topological_space.isomorphism
						âˆ€f: âˆˆ isomorphism,
						@f,
							D.p = C.p âˆ˜ f ; D â†’ C â†’ X
						â– 
					),
					automorphism:
					(
						âŠ† isomorphism,
						âŠ† set.endomorphism
					),
					; about alias
						deck_transformation: = automorphism, ; !
						covering_transformation: = automorphism,
					; end
					Aut(âˆ€C: âˆˆ covering_space): = {f|f âˆˆ automorphism}[âˆ€f: âˆˆ toplogical_space.C(C, C)],
			),
			; covering_space(X).isomorphism

			universal_covering_space(âˆ€X: âˆˆ connected_space): ; ? X may need to be path-connected and locally path-connected
			(
				âŠ† covering_space(X),
				âŠ† simple_connected_space ; +
			),
			[  universal covering space of X is the covring space of all the covering space of X ]
		; end
),