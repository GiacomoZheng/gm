: ; !+ set
(
	âˆˆ structure, ; define the isomorphism for the subclass of set
	; about ZFC (https://en.wikipedia.org/wiki/Zermeloâ€“Fraenkel_set_theory)
		`Source: "The Foundations of Mathematics" --- Kenneth Kunen`,
		(
			"if two set has totally he same elements, they are the same set, it means, there has the same attributes defined by set class"
			âˆ€A: âˆˆ set,
			âˆƒB: âˆˆ set, âˆ€x: âˆˆ â—‰, x âˆˆ A â‡” x âˆˆ B
		), ; 1. extension,
		[ for example:
			``` A set.= B â‡’ A âˆª C set.= B âˆª C ```
		 ]

		(
			âˆ€A: âˆˆ set,
			Â¬(A = âˆ…) â‡’
			(
				âˆƒx: âˆˆ A, x âˆˆ set â‡’ x âˆ© A = âˆ… ; if not, correct ; ? pure set or not
			)
		), ; 2. regularity or fundation

		(
			âˆ€A: âˆˆ set,
			âˆ€cls: âŠ† â—‰, ; ? set
			âˆƒB: âˆˆ set, âˆ€x: âˆˆ B, x âˆˆ cls, x âˆˆ A
		), ; 3. specification, or comprehension

		; (
		; 	âˆƒâˆ…: âˆˆ set,
		; 	âˆ€x: âˆˆ â—‰, Â¬(x âˆˆ â—‰)
		; ), ; 3.2: empty set
		; can be proved by extension and comprehension axiom, add with the existence of empty class

		(
			âˆ€A: âˆˆ set, âˆ€B: âˆˆ set,

		), ; 4. paring
		; (
		; 	âˆ€x: âˆˆ â—‰, âˆƒA: âˆˆ set,
		; 	âˆ€y: âˆˆ A, y = x
		; ), ; 4.2: existence singleton set
		(

		)
	; end

	; * I cannot deal with the âŠ† âˆˆ (for class) and âŠ† âˆˆ (for set)
		; * idea 1: differ the symbol for classes and samples
		; * idea 2: give other symbols for class

	âŠ† â—‰, ; I may change it to, âˆˆ structure
	(
		âˆ€X: âˆˆ set, ; +
		`
			my opinion about ZFC:
		`

		; attributes
			X.cover(âˆ€S: âˆˆ sub(X)):
			(
				"cover of S in X",
				; * the element in it may be empty, as I define the topology as a cover later
				âŠ† sub(Ps(X)), ; every element of the cover should be a subset of the X
				âˆ€ğ’: âˆˆ X.cover(S),
				S âˆˆ sub(â‹ƒ(ğ’)) ; ! â‹ƒ
			),
			X.partition:
			(
				âŠ† X.cover(X),
				âŠ† disjoint_sub(X),
				; âˆ€ğ’«: âˆˆ X.partition(X), ; Â¬({} âˆˆ ğ’«), ; ? for a partition, there can be an empty set inside, but it is not allowed in quotient
				; * In fact, I'm not sure about it, but I know
					; * covers can contain empty set
					; * quotient cannot contain empty set
			),
	),

	; location
		; about alias
			; ! countable: , ; this terminology may cause some ambiguity 
			; at_most_countable: = 
			countablely_infinite: = denumerable,
			enumerable: = denumerable, ; I don't think that using this term is a good idea indeed
		; end


		; + about structure
			sub(âˆ€S: âˆˆ set): ; ?
			(
				"subset",
				âŠ† set,
				âˆ€A: âˆˆ sub(S),
				âˆ€a: âˆˆ A, a âˆˆ S
			),

			Hom(âˆ€S: âˆˆ set)(âˆ€T: âˆˆ set): ; + the set of homomorphisms from S to T
			Epi(âˆ€S: âˆˆ set)(âˆ€T: âˆˆ set): ; +
			; Mon(âˆ€S: âˆˆ set)(âˆ€T: âˆˆ set): ; +
			End(âˆ€S: âˆˆ set): ; +
			; Iso(âˆ€S: âˆˆ set)(âˆ€T: âˆˆ set): ; +
			Aut(âˆ€S: âˆˆ set): ; +

			; + quotient
		; end

		; about special subsets
			disjoint_sub(âˆ€S: âˆˆ set):
			(
				"disjoint subset",
				âŠ† sub(S),
				âˆ€X: âˆˆ disjoint_sub(S), âˆ€Y: âˆˆ disjoint_sub(S),
				Â¬(X = Y) â‡’ X âˆ© Y = âˆ…
			),

			finite_sub(âˆ€S: âˆˆ set):
			(
				"finite subset",
				âŠ† finite, ; + to be define
				âŠ† sub(S),
			),
			disjoint_finite_sub(âˆ€S: âˆˆ set):
			(
				âŠ† finite_sub(S),
				âŠ† disjoint_sub(S),
			),
			
			countable_sub(âˆ€S: âˆˆ set):
			(
				"countable subset",
				âŠ† countable, ; ? countable I'm not sure about what it is 
				âŠ† sub(S),
			),
			disjoint_countable_sub(âˆ€S: âˆˆ set):
			(
				âŠ† countable_sub(S),
				âŠ† disjoint_sub(S),
			),
		; end

		quotient(âˆ€S: âˆˆ set):
		(
			âŠ† S.partition,
			âˆ€ğ’«: âˆˆ quotient(X),
			Â¬({} âˆˆ ğ’«) ; for the definition of quotient space / group
		),

		variable(âˆ€D: âˆˆ set): ; ?
		(
			"a generalization of random variable in statistics",
			"a subset which can work as an element"
			; for example: [0, 1] + [2, 4] = [2, 4], we can read it as the summation of two variables",
			; + it will be use in analysis to define something like polynomial or dy/dx
			âŠ† sub(D), ; Intuitively, the domain for it to pick some
			(
				âˆ€X: âˆˆ variable(D),
				; + I need to find the operators or relators on set
			)
		),
		[ hierarchy chain: variable âŠ‡ random_variable ]

		element(âˆ€S: âˆˆ set): ; +
		(
			"the class contains exactly what this S has; in another word, the class of elements of S",
		),

		Ps(âˆ€S: âˆˆ set): = set.sub(S).collect(), ; return a set ; + set.sub(S) is collectible

		#(âˆ€S: âˆˆ set):, ; + cardinal number of a set

		; + rewrite later (about universal property)
		Ã—: ; !
		(
			âˆˆ operator, ; !
			âˆ€A: âˆˆ set, âˆ€B: âˆˆ set,
			A Ã— B = {(x, y)}[âˆ€x: âˆˆ A, âˆ€y: âˆˆ B]
		),

		âˆª: ; ! ; + rewrite later (about universal property)
		(
			; âˆˆ
			âˆ€Ï„: âˆˆ set, ; set of set
			âˆª[](Ï„) = {x}[âˆ€x: âˆˆ â—‰, âˆƒC: âˆˆ Ï„, x âˆˆ C],

			âˆ€A: âˆˆ â—‰, âˆ€B: âˆˆ â—‰,
			âˆ€(A âˆˆ set, B âˆˆ set) â‡’ (A âˆª B) = âˆª[]({A, B})
		),

		âˆ©: ; ! ; + rewrite later (about universal property)
		(
			; âˆˆ

			âˆ€Ï„: âˆˆ set, ; set of set
			âˆ©[](Ï„) = {x}[âˆ€x: âˆˆ â—‰, âˆ€C: âˆˆ Ï„, x âˆˆ C], ; !

			âˆ€A: âˆˆ â—‰, âˆ€B: âˆˆ â—‰,
			âˆ€(A âˆˆ set, B âˆˆ set) â‡’ A âˆ© B = âˆ©[]({A, B}) ; !
		),
),
