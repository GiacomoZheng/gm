: ; !+ set
(
	; about ZFC (https://en.wikipedia.org/wiki/Zermeloâ€“Fraenkel_set_theory)
		(
			âˆ€A: âˆˆ set,
			âˆƒB: âˆˆ set, âˆ€x: âˆˆ â—‰, x âˆˆ A â‡” x âˆˆ B
		), ; 1. extension, ; ? I don't know why we need it

		(
			âˆ€A: âˆˆ set,
			!(A = âˆ…) â‡’
			(
				âˆƒx: âˆˆ A, x âˆˆ set â‡’ x âˆ© A = âˆ… ; ! if not?
			)
		), ; 2. regularity

		(
			âˆ€A: âˆˆ set,
			âˆ€cls: â—‰.âŠ† â—‰,
			âˆƒB: âˆˆ set, âˆ€x: âˆˆ B, x âˆˆ cls
		), ; 3. specification

		(
			âˆƒâˆ…: âˆˆ set,
			âˆ€x: âˆˆ â—‰, !(x âˆˆ â—‰)
		), ; 3.2: empty set
		(
			âˆ€x: âˆˆ â—‰, âˆƒA: âˆˆ set,
			âˆ€y: âˆˆ A, y = x
		), ; 3.3: existence singleton set
		(

		)
	; end

	; * I cannot deal with the âŠ† âˆˆ (for class) and âŠ† âˆˆ (for set)
	; * idea 1: differ the symbol for classes and samples
	; * idea 2: give other symbols for class

	â—‰.âŠ† â—‰,
	(
		âˆ€X: âˆˆ set, ; +

		; attributes
			X.cover(âˆ€S: âŠ† subset):
			(
				"cover of S, set of subsets",
				; * the element in it may be empty, as I define the topology as a cover latter
				â—‰.âŠ† sub(Ps(S)), ; every element of the cover should be a subset of the S of it
				âˆ€ğ’: âˆˆ X.cover(S),
				S âŠ† âˆª(ğ’)
			),
	),

	; location
		; about alias
			; ! countable: , ; this terminology may cause some ambiguity 
			; at_most_countable: = 
			countablely_infinite: = denumerable,
			enumerable: = denumerable, ; I don't think using this term is a good idea indeed
		; end

		quotient(âˆ€S: âˆˆ set):
		(
			â—‰.âŠ† cover(S), ; ?

			âˆ€ğ’«: âˆˆ quotient(S),
			!({} âˆˆ ğ’«),; ? others may not require the sets in partition nonempty
			âˆ€A: âˆˆ ğ’«, âˆ€B: âˆˆ ğ’«,
			!(A = B) â‡’ A âˆ© B = âˆ…
		),

		sub(âˆ€S: âˆˆ set):
		(
			"subset",
			â—‰.âŠ† set,
			âˆ€A: âˆˆ sub(S),
			âˆ€a: âˆˆ A, a âˆˆ S
		),
		âŠ†: (âˆˆ relator, &âŠ†&.r = sub), ; !

		element(âˆ€S: âˆˆ set): ; +
		(
		),

		Ps(âˆ€S: âˆˆ set): = {A}[âˆ€A: âŠ† S], ; + return a set ; I'll create another function return a class

		equal(âˆ€S: âˆˆ set): ; ?
		(
			â—‰.âŠ† set,
		),
		=: (âˆˆ relator, &=&.r = equal),

		Ã—: ; !
		(
			âˆˆ operator,
			âˆ€A: âˆˆ set, âˆ€B: âˆˆ set,
			A Ã— B = {(x, y)}[âˆ€x: âˆˆ A, âˆ€y: âˆˆ B]
		),

		âˆª: ; !
		(
			; âˆˆ
			âˆ€Ï„: âˆˆ set, ; set of set
			âˆª[](Ï„) = {x}[âˆ€x: âˆˆ â—‰, âˆƒC: âˆˆ Ï„, x âˆˆ C],

			âˆ€A: âˆˆ â—‰, âˆ€B: âˆˆ â—‰,
			âˆ€(A âˆˆ set, B âˆˆ set) â‡’ (A âˆª B) = âˆª[]({A, B})
		),

		âˆ©: ; !
		(
			; âˆˆ

			âˆ€Ï„: âˆˆ set, ; set of set
			âˆ©[](Ï„) = {x}[âˆ€x: âˆˆ â—‰, âˆ€C: âˆˆ Ï„, x âˆˆ C], ; !

			âˆ€A: âˆˆ â—‰, âˆ€B: âˆˆ â—‰,
			âˆ€(A âˆˆ set, B âˆˆ set) â‡’ A âˆ© B = âˆ©[]({A, B}) ; !
		),
),
